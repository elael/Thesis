\section{Algoritmo FIK}

A solução mais recente para tratar o problema de cinemática inversa na proximidade de configurações singulares é o algoritmo FIK ({\it Feedback Inverse Kinematics}), apresentado em \cite{P:08}. O método apresenta uma proposta alternativa que não exige inversão matricial e soluciona o problema ao empregar um laço de realimentação para minimizar a diferença entre as velocidades demandada e atual. 

A discrepância entre a velocidade atual $\dot{\bf x} \in {\mathbb R}^m$ e a velocidade demandada ${\bf v}_r \in {\mathbb R}^m$ pode ser representada pelo vetor de erro ${\bf e}_v \in {\mathbb R}^m$ dado por
%
\begin{equation}
\label{eq::fikerror}
{\bf e}_v = {\bf v}_r - {\bf J}({\bf q})\dot{{\bf q}}.
\end{equation} 
%
Considere o laço de realimentação mostrado na Figura \ref{fig::fikdiag}, onde ${\bf K}(s)\in {\mathbb R}^{n \times m}$ é uma função de transferência matricial completa.  Existe uma forma adaptativa para ${\bf K}(s)$ que reduz o erro em (\ref{eq::fikerror}) para um valor arbitrariamente pequeno, resultando na seguinte solução para o problema de cinemática inversa:
%  
%The error in (\ref{eq::fikerror}) can be minimized by constructing a feedback loop as shown in Fig. \ref{fig::fikdiag}. If ${\bf K}(s)\in {\mathbb R}^{n \times m}$ represents a full trasnfer function matrix that acts as a control law, then there exists and adaptive form of ${\bf K}(s)$ that minimizes this error to an arbitrary small value, leading to the following solution to the inverse kinematics problem:
%
\begin{equation}
\label{eq::fiklaw}
\dot{\bf q} = {\bf K}(s)({\bf J}{\bf K}(s) + {\bf I})^{-1}{\bf v}_r.
\end{equation} 
%
A matriz ${\bf K}(s)$ ótima apresenta a seguinte forma adaptativa:
%The optimal ${\bf K}(s)$ has the following adaptive form:
%
\begin{equation}
\label{eq::fikK}
{\bf K}(s) = {\bf J}^T({\bf q}){\mathcal G}(s{\bf I} - {\mathcal A})^{-1}
\end{equation}
%
onde ${\mathcal G} \in {\mathbb R}^{m \times m}$ é uma matriz positiva definida simétrica e ${\mathcal A} \in {\mathbb R}^{m \times m}$ é uma matriz negativa definida diagonal. 
%

\begin{figure}[htpb]
  \centering
  \def\JPicScale{0.7}
  {\small
  \input{fig/FIK.pst}
  }
  \caption{Feedback inversa kinematics block diagram}
  \label{fig::fikdiag}
\end{figure}

A forma ótima para ${\bf K}(s)$ é obtida a partir do seguinte problema de minimização:
%Initially all joint variables are fixed at some non-zero values ${\bf q}_0$. The corresponding Jacobian is then computed to serve as a time invariant, transfer matrix that maps joint velocites to Cartesian velocitiesm, i.e. ${\bf J}({\bf q}_0) = {\bf J}_0 = \text{constant}$. Then an optimal ${\mathcal H}_{\infty}$ control law can be designed to solve the following sensitivity minimization problem:
%
\begin{equation}
\label{eq::fikmin}
\begin{matrix}
\text{min} \\
{\bf K}(s) \\
\end{matrix}
\left\|
\left(
\begin{matrix}
 {\boldsymbol \omega}_1(s)({\bf J}_0{\bf K}(s)+{\bf I})^{-1} \\
 {\boldsymbol \omega}_2({\bf J}_0{\bf K}(s)+{\bf I})^{-1}
\end{matrix}
\right)
\right\|
\end{equation}
%
onde ${\bf J}_0 = {\bf J}({\bf q}_0)$ é calculada a partir do vetor ${\bf q}_0$ de variáveis não nulas de juntas, sendo utilizada para mapear as velocidades das juntas no espaço cartesiano. O termo ${\boldsymbol \omega}_1(s)\in {\mathbb R}^{m \times m}$ determina a largura de banda da lei de cinemática inversa, sendo obtido a partir de restrições dinâmicas do manipulador e da trajetória de referência, e ${\boldsymbol \omega}_2(s)\in {\mathbb R}^{m \times m}$ determina restrições para os atuadores, estabelecendo um limite superior para as velocidades $\dot{\bf q}$ desenvolvidas. 
%
%${\boldsymbol \omega}_1(s)\in {\mathbb R}^{m \times m}$ determines the badnwidth of the inverse kinematics law and is derived from the dynamic constraints of manipulator and the reference trajectory ${\bf x}_d$. ${\boldsymbol \omega}_2 \in {\mathbb R}^{n \times n}$ determines the constraints in the actuators in terms of the upper bound on the velocities $\dot{\bf q}$. Equation (\ref{eq::fikmin}) can be solved for ${\bf K}(s)$ by using standard ${\mathcal H}_\infty$ optimization algorithm.
%
Para a adaptação de ${\bf K}(s)$, a equação (\ref{eq::fikK}) pode ser reescrita no espaço de estados, como proposto em \cite{AP:09}. Assim,
%For the adaptation of ${\bf K}(s)$, (\ref{eq::fikK}) can be written in its state-space form which is of the following adaptive form:
%
\begin{equation}
{\bf K}(s): \left\{\begin{array}{ll}
\dot{\bf z} = {\bf A}{\bf z} + {\bf e}_v \\
\dot{\bf q} = ({\mathcal D}_{12}^T{\mathcal D}_{12})^{-1}{\bf J}({\bf q}){\mathcal B}^T{\mathcal P}{\mathcal B}{\bf z} \\
\end{array} \right.
\end{equation}
%
%onde 
%
%\begin{equation}
%{\mathcal G} = ({\mathcal D}_{12}^T{\mathcal D}_{12})^{-1}{\mathcal B}^T{\mathcal P}{\mathcal B}
%\end{equation}
%
onde ${\mathcal G} = ({\mathcal D}_{12}^T{\mathcal D}_{12})^{-1}{\mathcal B}^T{\mathcal P}{\mathcal B}$ e ${\bf z} \in {\mathbb R}^m$ corresponde ao vetor de estados do controlador. A matriz $\mathcal P$ é baseada na escolha de ${\bf J}_0$ e as matrizes ${\mathcal A}$,${\mathcal B}$ e ${\mathcal D}_{12}$ são matrizes diagonais dependentes dos parâmetros de desempenho, portanto ${\boldsymbol \omega}_1$ e ${\boldsymbol \omega}_2$. A matriz de transferência ${\boldsymbol \omega}_1(s)$ é diagonal e dada por 
%  
%${\bf J}({\bf q})$ can be computed at every sample time by using current information of ${\bf q}$. The ${\bf z} \in {\mathbb R}^m$ represents the state of the controller, ${\mathcal A},{\mathcal B},{\mathcal D}_{12}$ are diagonal matrices contributed from perfomance weights (${\boldsymbol \omega}_1$, ${\boldsymbol \omega}_2$) and ${\bf e}_v$ is the error as defined in (\ref{eq::fikerror}). ${\boldsymbol \omega}_1(s)$ is a diagonal transfer-function matrix and is given as:
%
\begin{equation}
{\boldsymbol \omega}_1(s) = \frac{b}{s+\alpha}{\bf I}%^{m \times m}
\end{equation}
%
onde $b$ determina a largura de banda da lei de cinematica inversa e $\alpha$ é o ganho de saturação do integrador em baixas frequências. Assim, ${\mathcal A}$ pode ser escrita como 
%where $b$ determines the bandwidth of FIK law and $\alpha$ is the saturation gain of integrator at low frequencies. With this form of ${\boldsymbol \omega}_1(s)$,${\mathcal A}$ transforms to:
%
\begin{equation}
{\mathcal A} = -\alpha {\bf I}%^{m \times m}
\end{equation}
%
%${\boldsymbol \omega}_1(s)$ allows specifying the tracking accuracy and is linked to the dynamics of desired trajectory and it can be specified for eachm-direction independently by setting $b$ and $\alpha$ differently for each direction in ${\boldsymbol \omega}_1(s)$. The actuator constraints are specified in %${\boldsymbol \omega}_2$. This is done for each degree of freedom ($n$).
O termo ${\boldsymbol \omega}_2$ está relacionado às restrições nos atuadores do manipulador e, dada uma velocidade máxima de junta $\omega$, pode ser escirto como
%
\begin{equation}
{\boldsymbol \omega}_2 = \frac{1}{\omega}{\bf I}%^{n \times n}
\end{equation}
%
%where, $\omega$ is the maximum joint rate. The FIK law allows weighing each degree of freedom independently in ${\boldsymbol \omega}_2$
Nota-se que tanto ${\boldsymbol \omega}_1$ e ${\boldsymbol \omega}_2$ podem ser especificados independentemente em cada direção $m$ ou grau de liberdade $n$, respectivamente. Apesar de utilizar uma abordagem bastante diferente para solucionar o problema de cinemática inversa, o algoritmo FIK apresenta algumas similaridades com o algoritmo DLS apresentado anteriormente. De fato, semelhanças na estrutura da solução são bem evidentes, e, considerando 
%Although FIK law uses a very different approach to solve inverse kinematics however if it is carefully analyzed then similarities can be found in its structure with damped least square inverse kinematics law. By susbtituting:
%
\begin{equation}
{\bf Q} = {\mathcal P}(s{\bf I} - {\mathcal A})^{-1},
\end{equation}
%
a solução apresentada em (\ref{eq::fiklaw}) se torna 
%can be written into a compact form such as:
%
\begin{equation}
\dot{\bf q} = {\bf J}^T{\bf Q}({\bf JJ}^T{\bf Q} + {\bf I})^{-1}{\bf v}_r.
\end{equation}
%
Nota-se que as soluções (\ref{eq::fiklaw}) e (\ref{eq:dlslaw}) apresentam a mesma estrutura exceto pela diferença entre os termos $\lambda$ e ${\bf Q}$. A solução proposta pelo método FIK utiliza uma função dinâmica de mapeamento ${\bf Q}(s)$ e considera $\lambda = 1$, não exigindo portanto o cálculo dos valores singulares da matriz Jacobiana. Em comparação com o algoritmo DLS, o método FIK proporciona robustez a singularidades devido à forma não-diagonal e dinâmica de ${\bf Q}(s)$.
%
%By comparing (\ref{eq::fiklaw}) with (\ref{eq:dlslaw}), it can be observed that both have the same structure except the difference between $\lambda$ and ${\bf Q}$. Instead of using any damping factor $\lambda$, the FIK law uses a dynamic mapping function ${\bf Q}(s)$ in (\ref{eq::fiklaw}). In toher words in FIK law $\lambda = 1$, therefore, there is no need of computation of singular value decomposition of Jacobian. In comparison to the damped least square methods, the FIK method provides singularity robustness due to non-diagonal and dynamic form of ${\bf Q}(s)$.
%
As velocidades das juntas $\dot{\bf q}$ estão relacionadas às velocidades demandadas no espaço cartesiano através da função de controle ${\bf J}^T{\bf Q}({\bf JJ}^T{\bf Q} + {\bf I})^{-1}$ e, uma vez que a solução é obtida através de um laço de realimentação, não é necessária a inversão da matriz Jacobiana. Desta forma, o custo computacional do método é reduzido consideravelmente.
%
%Due to the use of feedback loop in FIK, the joint velocities are related to demanded Cartesian velocities through control sensitive function ${\bf J}^T{\bf Q}({\bf JJ}^T{\bf Q} + {\bf I})^{-1}$ as shown in (\ref{eq::fiklaw}) and since the computation is done in feedback loop it does not require computing inverse of the Jacobian. As a conseguence, computational demand is reduced to a great extent. 
%
De (\ref{eq::fiklaw}), a estabilidade da solução FIK é garantida desde que
%From (\ref{eq::fiklaw}), the stability of FIK law is guaranteed as long as:
%
\begin{equation}
\det({\bf JJ}^T{\bf Q} + {\bf I}) \neq 0.
\end{equation}
%
Isto é, para todas as configurações ${\bf q}$, a seguinte igualdade deve ser verificada: 
%In other words, for all combinations in $q$ for any singular value the following must hold true:
%
\begin{equation}
\sigma({\bf JJ}^T{\bf Q})\geq0
\end{equation}
%
Uma vez que ${\bf Q} = {\mathbf Q}^T \geq {\bf 0}$, este requisito é sempre satisfeito e não depende de ${\bf q}$.
%
%Since ${\bf Q} = {\mathbf Q}^T \geq$, this requirement is always satisfied and does not depend on ${\bf q}$.
