\section{Algoritmo FIK}

The most recent development in this field is feedback inverse kinematics (FIK) method \cite{P:08} to solve IK problems. FIK uses a different approach and solves inverse kinematics problem from a control perspective by employing a feedback control to minimize the difference between demanded and actual Cartesian velocities. The required space trajectory is derived trhough the control sensitivity function within the feedback loop.

The discrepancy between the current Cartesian velocities $\dot{\bf x}\in {\mathbb R}^m$ and the desired Cartesian velocities ${\bf v}_r \in {\mathbb R}^m$ can be represented by an error vector ${\bf e}_v \in {\mathbb R}^m$ as shown in Fig. \ref{fig::fikdiag}.
%
\begin{equation}
\label{eq::fikerror}
{\bf e}_v = {\bf v}_r - {\bf J}({\bf q})\dot{{\bf q}}.
\end{equation} 
%
The error in (\ref{eq::fikerror}) can be minimized by constructing a feedback loop as shown in Fig. \ref{fig::fikdiag}. If ${\bf K}(s)\in {\mathbb R}^{n \times m}$ represents a full trasnfer function matrix that acts as a control law, then there exists and adaptive form of ${\bf K}(s)$ that minimizes this error to an arbitrary small value, leading to the following solution to the inverse kinematics problem:
%
\begin{equation}
\label{eq::fiklaw}
\dot{\bf q} = {\bf K}(s)({\bf J}{\bf K}(s) + {\bf I})^{-1}{\bf v}_r.
\end{equation} 
%
The optimal ${\bf K}(s)$ has the following adaptive form:
%
\begin{equation}
\label{eq::fikK}
{\bf K}(s) = {\bf J}^T({\bf q})p(s{\bf I} - {\mathcal A})^{-1}
\end{equation}
%
onde $p \in {\mathbb R}^{m \times m}$, is a positive definite symmetric gain matrix and ${\mathcal A} \in {\mathbb R}^{m \times m}$ is a negative definite diagonal matrix.
%

\begin{figure}[htpb]
  \centering
  \def\JPicScale{0.8}
  {\small
  \input{fig/FIK.pst}
  }
  \caption{Feedback inversa kinematics block diagram}
  \label{fig::fikdiag}
\end{figure}

Initially all joint variables are fixed at some non-zero values ${\bf q}_0$. The corresponding Jacobian is then computed to serve as a time invariant, transfer matrix that maps joint velocites to Cartesian velocitiesm, i.e. ${\bf J}({\bf q}_0) = {\bf J}_0 = \text{constant}$. Then an optimal ${\mathcal H}_{\infty}$ control law can be designed to solve the following sensitivity minimization problem:
%
\begin{equation}
\label{eq::fikmin}
\begin{matrix}
\text{min} \\
{\bf K}(s) \\
\end{matrix}
\left\|
\left(
\begin{matrix}
 {\boldsymbol \omega}_1(s)({\bf J}_0{\bf K}(s)+{\bf I})^{-1} \\
 {\boldsymbol \omega}_2({\bf J}_0{\bf K}(s)+{\bf I})^{-1}
\end{matrix}
\right)
\right\|
\end{equation}
%
${\boldsymbol \omega}_1(s)\in {\mathbb R}^{m \times m}$ determines the badnwidth of the inverse kinematics law and is derived from the dynamic constraints of manipulator and the reference trajectory ${\bf x}_d$. ${\boldsymbol \omega}_2 \in {\mathbb R}^{n \times n}$ determines the constraints in the actuators in terms of the upper bound on the velocities $\dot{\bf q}$. Equation (\ref{eq::fikmin}) can be solved for ${\bf K}(s)$ by using standard ${\mathcal H}_\infty$ optimization algorithm.
%
For the adaptation of ${\bf K}(s)$, (\ref{eq::fikK}) can be written in its state-space form which is of the following adaptive form:
%
\begin{equation}
{\bf K}(s): \left\{\begin{array}{ll}
\dot{\bf z} = {\bf A}{\bf z} + {\bf e} \\
\dot{\bf q} = ({\mathcal D}_{12}^T{\mathcal D}_{12})^{-1}{\bf J}({\bf q}){\mathcal B}^T{\mathcal P}{\mathcal B}{\bf z} \\
\end{array} \right.
\end{equation}
%
onde 
%
\begin{equation}
p = ({\mathcal D}_{12}^T{\mathcal D}_{12})^{-1}{\mathcal B}^T{\mathcal P}{\mathcal B}
\end{equation}
%
${\bf J}({\bf q})$ can be computed at every sample time by using current information of ${\bf q}$. The ${\bf z} \in {\mathbb R}^m$ represents the state of the controller, ${\mathcal A},{\mathcal B},{\mathcal D}_{12}$ are diagonal matrices contributed from perfomance weights (${\boldsymbol \omega}_1$, ${\boldsymbol \omega}_2$) and ${\bf e}_v$ is the error as defined in (\ref{eq::fikerror}). ${\boldsymbol \omega}_1(s)$ is a diagonal transfer-function matrix and is given as:
%
\begin{equation}
{\boldsymbol \omega}_1(s) = \frac{b}{s+\alpha}{\bf I}%^{m \times m}
\end{equation}
%
where $b$ determines the bandwidth of FIK law and $\alpha$ is the saturation gain of integrator at low frequencies. With this form of ${\boldsymbol \omega}_1(s)$,${\mathcal A}$ transforms to:
%
\begin{equation}
{\mathcal A} = -\alpha {\bf I}%^{m \times m}
\end{equation}
%
${\boldsymbol \omega}_1(s)$ allows specifying the tracking accuracy and is linked to the dynamics of desired trajectory and it can be specified for eachm-direction independently by setting $b$ and $\alpha$ differently for each direction in ${\boldsymbol \omega}_1(s)$. The actuator constraints are specified in ${\boldsymbol \omega}_2$. This is done for each degree of freedom ($n$).
%
\begin{equation}
{\boldsymbol \omega}_2 = \frac{1}{\omega}{\bf I}%^{n \times n}
\end{equation}
%
where, $\omega$ is the maximum joint rate. The FIK law allows weighing each degree of freedom independently in ${\boldsymbol \omega}_2$
%
Although FIK law uses a very different approach to solve inverse kinematics however if it is carefully analyzed then similarities can be found in its structure with damped least square inverse kinematics law. By susbtituting:
%
\begin{equation}
{\bf Q} = p(s{\bf I} - {\mathcal A})^{-1}
\end{equation}
%
FIK law in (\ref{eq::fiklaw}) can be written into a compact form such as:
%
\begin{equation}
\dot{\bf q} = {\bf J}^T{\bf Q}({\bf JJ}^T{\bf Q} + {\bf I})^{-1}{\bf v}_r.
\end{equation}
%
By comparing (\ref{eq::fiklaw}) with (\ref{eq:dlslaw}), it can be observed that both have the same structure except the difference between $\lambda$ and ${\bf Q}$. Instead of using any damping factor $\lambda$, the FIK law uses a dynamic mapping function ${\bf Q}(s)$ in (\ref{eq::fiklaw}). In toher words in FIK law $\lambda = 1$, therefore, there is no need of computation of singular value decomposition of Jacobian. In comparison to the damped least square methods, the FIK method provides singularity robustness due to non-diagonal and dynamic form of ${\bf Q}(s)$.
%
Due to the use of feedback loop in FIK, the joint velocities are related to demanded Cartesian velocities through control sensitive function ${\bf J}^T{\bf Q}({\bf JJ}^T{\bf Q} + {\bf I})^{-1}$ as shown in (\ref{eq::fiklaw}) and since the computation is done in feedback loop it does not require computing inverse of the Jacobian. As a conseguence, computational demand is reduced to a great extent. From (\ref{eq::fiklaw}), the stability of FIK law is guaranteed as long as:
%
\begin{equation}
\det({\bf JJ}^T{\bf Q} + {\bf I}) \neq 0.
\end{equation}
%
In other words, for all combinations in $q$ for any singular value the following must hold true:
%
\begin{equation}
\sigma({\bf JJ}^T{\bf Q})\geq0
\end{equation}
%
Since ${\bf Q} = {\mathbf Q}^T \geq$, this requirement is always satisfied and does not depend on ${\bf q}$.